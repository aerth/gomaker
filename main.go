/*

gomaker

Makefile generator for Go projects

Use like this:

    gomaker -o Makefile --options "static,lite,commit"

With the sane default settings, that same command is typed:

    gomaker .

To build with a literal "go build", `gomaker --options "none"`

Here are the options,
They should be comma separated in the --options flag, and inside double quotes.

    none: normal go build, Shell: go build
    v: verbose build, Shell go build -x
    lite:  no debug symbols, Shell: --ldflags '-s'
    commit: try adding version info into the mix
*/

package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	"github.com/aerth/filer"
)

var (
	version    = "gomaker (undefined version)"
	debug      = flag.Bool("debug", false, "Verbose logging to debug.log file")
	outputFile = flag.String("o", "Makefile", "")
	options    = flag.String("options", "static,verbose,lite,commit", "Options. Use --options=\"comma,sep,list\""+optionhelp)
	optionhelp = `

  [Options]
  none: normal go build, Shell: go build
  verbose: verbose build, Shell: go build -x
  lite:  no debug symbols, Shell: --ldflags '-s'
  commit: try adding version info into the mix
	static: try making a static linked binary (no deps)`
)

func main() {
	flag.Parse()
	args := flag.Arg(0)
	if args == "." {
		args = os.Getenv("PWD")
	}
	if !strings.Contains(args, ".") {
		flag.Usage()
		os.Exit(2)
	}
	fmt.Println("gomaker options:", *options)
	var linein = make(chan string)
	go builder(linein, args)
	writer(linein)
	//fmt.Println("All done!")
}

// Fatal Error
func fatal(ss ...interface{}) {

	if len(ss) == 1 {
		fmt.Println(ss)
	} else {
		fmt.Printf(ss[0].(string), ss[1:])
	}
	os.Exit(1)
}

// We need main or bust!
func aMainPackage(args string) bool {
	if !strings.Contains(args, "/") {
		panic("version 2 maibee")
	}
	f := getOneGoFile(args)
	if f == "" {
		fatal("Bug #1")
		return false
	}
	pname := gethead(args, f)
	if pname == "main" {
		return true
	}
	fatal("main !=", pname, args+f)
	return false
}

// Since all proper Go source files have an uncommented package name, this works!
func getOneGoFile(dirname string) (goFileName string) {
	fileinfo, err := ioutil.ReadDir(dirname)
	if err != nil {
		panic(err)
	}
	for _, file := range fileinfo {
		n := file.Name()
		if strings.HasSuffix(n, ".go") && !strings.HasPrefix(n, ".") {
			return n
		}
	}
	return ""
}

// Return the package name of a *.go file, (not with the word "package ")
func gethead(dir, goFilename string) string {
	if dir != "" {
		dir += "/"
	}
	file, err := os.Open(dir + goFilename)
	if err != nil {
		panic(err)
	}
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		s := scanner.Text()
		if strings.HasPrefix(s, "package ") {
			return strings.Split(s, " ")[1]
		}
	}
	if scanner.Err() != nil {
		panic(scanner.Err())
	}
	return "" // This would actually cause a build error. We are just sending a ""
}

func writer(linein chan string) {
	filer.Create(*outputFile)
	filer.Write(*outputFile, []byte(""))
	for {
		select {
		case line := <-linein:
			if line == "X" {
				return
			}
			filer.Append(*outputFile, []byte(line+"\n"))
			//fmt.Println("Appended", line)
		}
	}
}

func builder(linein chan string, args string) {
	if !aMainPackage(args) {
		os.Exit(2)
	}
	dirname := strings.Split(args, "/")
	projectName := dirname[len(dirname)-1]

	fmt.Println("Project Name:", projectName)
	linein <- "# " + projectName
	linein <- "# " + "Makefile generated by " + version
	linein <- "\n"
	op := strings.Split(*options, ",")

	if len(op) == 1 && op[0] == "" {
		op = []string{"none"}
	}
	if strings.Contains(*options, "none") {
		op = []string{"none"}
	}

	var ldflags, buildflags string
	for _, option := range op {

		switch option {
		case "static":
			linein <- `export CGO_ENABLED=0`
		case "commit":

			linein <- `COMMIT=$(shell git rev-parse --verify --short HEAD)`
			linein <- `RELEASE=${NAME}-c${COMMIT}`
			ldflags += `-X main.version=$(RELEASE) `
		case "lite":
			ldflags += `-s `
		case "none":
			//buildstring = ""
		case "verbose":
			buildflags += "-x "
		}

	}
	linein <- "NAME=" + projectName
	linein <- "\n"
	linein <- "build:"
	if ldflags != "" {
		ldflags = "--ldflags " + strconv.Quote(ldflags)
	}
	linein <- "\tgo build " + buildflags + ldflags
	linein <- "\n"
	linein <- "install:"
	linein <- "\tsudo mv ${NAME} /usr/local/bin/"

	linein <- "X" // All done.

}
